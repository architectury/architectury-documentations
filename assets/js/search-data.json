{"0": {
    "doc": "Access Transformer",
    "title": "Access Transformer",
    "content": "# Access Transformer {: .no_toc } --- Access Transformers must be created in `META-INF/accesstransformer.cfg`, in MCP and SRG mappings. (Basically keep your ATs from Forge, don't remap them) You may also refer to the [Forge Documentation](https://mcforge.readthedocs.io/en/latest/advanced/accesstransformers/) on this topic if you are new to this. ",
    "url": "https://docs.architectury.dev/docs/forge_loom/access_transformer.html",
    "relUrl": "/docs/forge_loom/access_transformer.html"
  },"1": {
    "doc": "Changing Log Level",
    "title": "Changing Log Level",
    "content": "# Changing Log Level {: .no_toc } --- Property `fabric.log.level` (Defaulted **info**) is used for managing the log level to SOUT. You can override this property by declaring the following: ```groovy loom { launches { client { property \"fabric.log.level\", \"debug\" } server { property \"fabric.log.level\", \"debug\" } } } ` ``` ",
    "url": "https://docs.architectury.dev/docs/forge_loom/changing_log_level.html",
    "relUrl": "/docs/forge_loom/changing_log_level.html"
  },"2": {
    "doc": "Data Generators",
    "title": "Data Generators",
    "content": "# Data Generators {: .no_toc } --- Data Generators Support has been added to Architectury Loom, starting from 0.6.55, this is how you declare it: ```groovy loom { dataGen { mod \"YOUR MODID HERE\" } } ``` Run `runData` or use your IDE's run configurations to generate the assets, should be the same as ForgeGradle. Architectury Loom automatically adds the following arguments: `--all --mod | --output `, if you wish to add more (like `--existing`), following is an example on how to add additional arguments: ```groovy loom { launches { data { arg \"--existing\", file(\"src/main/resources\").absolutePath } } } ``` **NOTE:** Data Generators are still in development for architectury / fabric projects, this is **only** for Forge projects! ",
    "url": "https://docs.architectury.dev/docs/forge_loom/data_generators.html",
    "relUrl": "/docs/forge_loom/data_generators.html"
  },"3": {
    "doc": "Discuss",
    "title": "Discuss",
    "content": "# Discuss {: .no_toc } --- For support and discussions, you may use [the Architectury Discord Server](https://discord.architectury.dev/). ",
    "url": "https://docs.architectury.dev/docs/discuss.html",
    "relUrl": "/docs/discuss.html"
  },"4": {
    "doc": "ExpectPlatform Annotation",
    "title": "ExpectPlatform Annotation",
    "content": "# ExpectPlatform Annotation {: .no_toc } --- `@ExpectPlatform` can be applied to **static methods**, and its content will be replaced by the platform-specific implementation. Here we will declare a method with `@ExpectPlatform`, please note that you don't need to do this to get the configuration directory *if you are using the Architectury API*. ```java package net.examplemod; import dev.architectury.injectables.annotations.ExpectPlatform; import java.io.File; class ExampleClass { @ExpectPlatform static File getConfigDirectory() { // Just throw an error, the content should get replaced at runtime. // Something is terribly wrong if this is not replaced. throw new AssertionError(); } } ``` Now, we can go and implement the platform-specific version of this method, we will do Fabric as an example. The package of this class is suffixed with `.fabric`, and the name of this platform-specific class is suffixed with `Impl`. ```java package net.examplemod.fabric; import net.fabricmc.loader.api.FabricLoader; import java.io.File; public class ExampleClassImpl { public static File getConfigDirectory() { return FabricLoader.getInstance().getConfigDir().toFile(); } } ``` ",
    "url": "https://docs.architectury.dev/docs/architectury_plugin/expect_platform.html",
    "relUrl": "/docs/architectury_plugin/expect_platform.html"
  },"5": {
    "doc": "Fixing ForgeGradle Mixin refmaps",
    "title": "Fixing ForgeGradle Mixin refmaps",
    "content": "# Fixing ForgeGradle Mixin refmaps {: .no_toc } --- **TL;DR: Follow the following [GitHub comment](https://github.com/SpongePowered/Mixin/issues/462#issuecomment-791370319).** The following applies to FG3 and sub-sequence versions if there are no fixes regarding this issue. ### Addressing some misconceptions Setting the property `mixin.env.disableRefMap` is **not** a proper fix, it may work for projects *with the same mappings*, as you are expecting that the original source of the mixin files to be in the same mappings as your development environment, which is false for some projects. (And is extremely unstable, will even break if you have a different MCP version.) ### Alternative Solutions Specifying `mixin.env.refMapRemappingFile` or providing `net.minecraftforge.gradle.GradleStart.srg.srg-mcp` may be an alternative fix. ",
    "url": "https://docs.architectury.dev/docs/forge_loom/fg_broken_refmap.html",
    "relUrl": "/docs/forge_loom/fg_broken_refmap.html"
  },"6": {
    "doc": "Fluids",
    "title": "Fluids",
    "content": "# Fluids {: .no_toc } --- ## FluidStack `FluidStack` is a platform-agnostic API of handling a `Fluid` type, `CompoundTag` nbt, and `long` amount. The actual implementation differs with the platform, with `81000L` and `1000` being the bucket amount for Fabric and Forge respectively. You may convert between Architectury's `FluidStack` with Forge's `FluidStack` and Fabric's `FluidVariant` with `FluidStackHooksFabric` and `FluidStackHooksForge`. Methods that convert from Architectury to platform does not do a copy, while the reverse will create a wrapper object that could be memory-intensive. ### ArchitecturyFluidAttributes `ArchitecturyFluidAttributes` allows declaring more properties for creating and defining a fluid. Most of the methods contain nullable types, please make sure you check the null-ability often. ### SimpleArchitecturyFluidAttributes `SimpleArchitecturyFluidAttributes` is a simple implementation of `ArchitecturyFluidAttributes` with a builder-style setup. Extending this class may be easier than extending the base interface. #### Creating the Attributes ```java public static final ArchitecturyFluidAttributes EXAMPLE_FLUID_ATTRIBUTES = SimpleArchitecturyFluidAttributes.ofSupplier(() -> EXAMPLE_FLUID, () -> EXAMPLE_FLUID_FLOWING); ``` `FLOW` and `SOURCE` isn't defined yet, we will define them later. With `SimpleArchitecturyFluidAttributes`, you can define extra attributes of the fluid, such as the texture, color, temperature, or whether it can infinitely convert to source. You can read the JavaDocs of `ArchitecturyFluidAttributes`. ## Registering Fluids #### Registrar Order On Forge, Fluid Registry is ran **after** blocks, that is why the `LiquidBlock` constructor takes a supplier of the fluid you create afterwards. However, this isn't the same on Fabric, registering fluids should go before registering blocks. If you are using the `DeferredRegister` API to register content (see [#Registry](/docs/architectury_api/registry)), you should move `FLUIDS.register()` before `BLOCKS.register()` and `ITEMS.register()`. The order of `.register()` does not matter on Forge, but it does on Fabric where it registers immediately. #### Creating the Fluid ```java public static final RegistrySupplier EXAMPLE_FLUID = FLUIDS.register(\"example_fluid\", () -> new ArchitecturyFlowingFluid.Source(EXAMPLE_FLUID_ATTRIBUTES)); public static final RegistrySupplier EXAMPLE_FLUID_FLOWING = FLUIDS.register(\"example_fluid_flowing\", () -> new ArchitecturyFlowingFluid.Flowing(EXAMPLE_FLUID_ATTRIBUTES)); ``` #### Creating the Fluid Block ```java // Copying the fluid block properties of a water block, you can change that public static final RegistrySupplier EXAMPLE_FLUID_BLOCK = BLOCKS.register(\"example_fluid\", () -> new ArchitecturyLiquidBlock(EXAMPLE_FLUID, BlockBehaviour.Properties.copy(Blocks.WATER))); ``` #### Creating the Fluid Bucket ```java public static final RegistrySupplier EXAMPLE_FLUID_BUCKET = ITEMS.register(\"example_fluid_bucket\", () -> new ArchitecturyBucketItem(EXAMPLE_FLUID, new Item.Properties().tab(EXAMPLE_TAB))); ``` #### Adding our blocks and buckets to the Attribute You may find that some of these fields are not accessible because they are forward referencing, you can avoid this by qualifying the field owner class. ```java public static final ArchitecturyFluidAttributes EXAMPLE_FLUID_ATTRIBUTES = new SimpleArchitecturyFluidAttributes(() -> ExampleRegistries.EXAMPLE_FLUID, () -> ExampleRegistries.EXAMPLE_FLUID_FLOWING) .blockSupplier(() -> ExampleRegistries.EXAMPLE_FLUID_BLOCK) .bucketItemSupplier(() -> ExampleRegistries.EXAMPLE_FLUID_BUCKET); ``` #### Adding the fluid to Tags A lot of the logic depends on vanilla tag `#minecraft:water` and `#minecraft:lava`, you can read more on them [here](https://minecraft.fandom.com/wiki/Tag#Fluids). ",
    "url": "https://docs.architectury.dev/docs/architectury_api/fluids.html",
    "relUrl": "/docs/architectury_api/fluids.html"
  },"7": {
    "doc": "Getting Started",
    "title": "Getting Started",
    "content": "# Getting Started {: .no_toc } --- ## The Easy Way (100% From Scratch) Download templates from [Architectury Templates](https://github.com/architectury/architectury-templates) and import build.gradle as a project. ## The Not Quite So Easy Way (Converting [Fabric Mods](https://github.com/FabricMC/fabric-example-mod) to Forge) - Within `settings.gradle`, insert the repository to Architectury Loom (as well as Forge's maven for Forge / MCP / etc.): ```diff pluginManagement { repositories { maven { url \"https://maven.fabricmc.net/\" } + maven { url \"https://maven.architectury.dev/\" } + maven { url \"https://files.minecraftforge.net/maven/\" } gradlePluginPortal() } } ``` - Within `gradle.properties`, insert `loom.platform=forge`. - Within `build.gradle`, go to the `plugins` block and replace `fabric-loom` with any version of `dev.architectury.loom`, for example: ```diff plugins { - id 'fabric-loom' version '' + id 'dev.architectury.loom' version '0.12.0-SNAPSHOT' id 'maven-publish' } ``` **NOTE:** 0.12.0-SNAPSHOT is the current recommended version. - Insert the Forge dependency in the `dependencies` block: ```groovy dependencies { forge \"net.minecraftforge:forge:${mc_version}-${forge_version}\" } ``` ## Generating Sources You can generate the Minecraft sources for reference (since IDEA already has a decompiler this is only useful for searching through the code): Run the `genSources` Gradle task. If your IDE doesn't have Gradle integration, then run the following command in the terminal: `gradlew genSources` ( or `./gradlew genSources` on Unix-based systems). ## Run Configurations ### IntelliJ IDEA Run Configurations should be automatically generated on configuration, please **DO NOT** run `gradlew idea` as it may mess up your project. ### Visual Studio Code Run Configurations should be automatically generated on configuration, please **DO NOT** run `gradlew vscode` as it may mess up your project. ### CLI Run `gradlew runClient` or `gradlew runServer`. ",
    "url": "https://docs.architectury.dev/docs/forge_loom/getting_started.html",
    "relUrl": "/docs/forge_loom/getting_started.html"
  },"8": {
    "doc": "Getting Started",
    "title": "Getting Started",
    "content": "# Getting Started {: .no_toc } --- Download templates from [Architectury Templates](https://github.com/architectury/architectury-templates/releases/) and import it as a Gradle project. You will want to change every reference of examplemod to your mod, this includes `gradle.properies`, `fabric.mod.json`, `META-INF/mods.toml`, `quilt.mod.json` (If Applicable), and relocate the classes. You will also need to change the access widener file name in `common/build.gradle`. ## I don't want Architectury API... Remove lines related to Architectury API in each of the `build.gradle` in `common/`, `fabric/`, and `forge/`. They should look at this: ```diff dependencies { // We depend on fabric loader here to use the fabric @Environment annotations and get the mixin dependencies // Do NOT use other classes from fabric loader modImplementation \"net.fabricmc:fabric-loader:${rootProject.fabric_loader_version}\" // Remove the next line if you don't want to depend on the API - modApi \"dev.architectury:architectury:${rootProject.architectury_version}\" } ``` ## I want Yarn instead... Replace the line for the default Mojang Mappings in the root `build.gradle`, with one that references Yarn instead: ```diff subprojects { apply plugin: \"dev.architectury.loom\" loom { silentMojangMappingsLicense() } dependencies { minecraft \"com.mojang:minecraft:${rootProject.minecraft_version}\" - // The following line declares the mojmap mappings, you may use other mappings as well - mappings loom.officialMojangMappings() // The following line declares the yarn mappings you may select this one as well. - // mappings \"net.fabricmc:yarn:@YARN_MAPPINGS@:v2\" + mappings \"net.fabricmc:yarn:@YARN_MAPPINGS@:v2\" } } ``` ",
    "url": "https://docs.architectury.dev/docs/architectury_api/getting_started.html",
    "relUrl": "/docs/architectury_api/getting_started.html"
  },"9": {
    "doc": "Architectury Plugin",
    "title": "Architectury Plugin",
    "content": "# Architectury Plugin {: .no_toc } --- Architectury Plugin is a Gradle plugin to allow easier multi-modloader set-ups using a common module. ## Things to know ### Same Limitations as Architectury Loom [Read Me](/docs/forge_loom) for things to know on using Architectury Loom. ### Unstable + Issues Architectury Plugin is an experimental project, issues may arise, make sure you report them to the issue tracker. ### Gradle Version Support Architectury Plugin supports **Gradle 5.5.1** and up, with support for future versions of Gradl. ### Things that are transformed - `@Environment` and `EnvType` are remapped to `@OnlyIn` and `Dist` - `@ExpectPlatform` will be transformed to their platform-specific implementations ([Read More](/docs/architectury_plugin/platform_specific)) - A fake forge mod will be generated for dev testing to make forge treat the common module as a mod - Classes annotated with `@ForgeEvent` or `@ForgeEventCancellable` will extend forge's `Event` class on forge. ### Access Transformer / Access Widener You must have an identical AT and AW for the common module, the fabric module and the forge module, currently, there is no easy way to translate between ATs and AW, you just have to translate them manually, or use mixin `@Invoker` and `@Accessor`. ### Do not use vanilla Registry class for registering Forge disallows registering to the vanilla `Registry` class, you must defer your registrations to the `RegistryEvent.Add`. Architectury API provides an abstraction for ForgeRegistries and vanilla's Registry for registering content. ([Read More](/docs/architectury_api/registry)) ",
    "url": "https://docs.architectury.dev/docs/architectury_plugin/",
    "relUrl": "/docs/architectury_plugin/"
  },"10": {
    "doc": "Architectury API",
    "title": "Architectury API",
    "content": "# Architectury API {: .no_toc } --- Architectury API is an **optional** intermediary library which mods may utilize to ease developing multiplatform mods. ## What is Architectury API Architectury API is an API to abstract calls to Fabric API and Forge API as both loaders have different implementations and interfaces. Architectury updates regularly, with new hooks and features. Currently contains over 80 events hooks, networking abstraction, loader calls abstraction, game registry abstraction and more. ",
    "url": "https://docs.architectury.dev/docs/architectury_api/",
    "relUrl": "/docs/architectury_api/"
  },"11": {
    "doc": "Architectury Loom",
    "title": "Architectury Loom",
    "content": "# Architectury Loom {: .no_toc } --- Architectury Loom is a replacement plugin to Forge Gradle, based on FabricMC Loom. ## Things to know ### Limited IDE Support Architectury Loom currently only supports [IntelliJ IDEA](https://www.jetbrains.com/idea/) and [Visual Studio Code](https://code.visualstudio.com/). Other IDEs are not tested and are not supported. ### Unstable + Issues Architectury Loom is an experimental project. Thus, issues may arise, make sure you report them to the issue tracker. ### Mapping Options You may use [Yarn](https://www.github.com/FabricMC/yarn/) or Official Mojang Mappings for Architectury Loom, [MCP](/docs/forge_loom/using_mcp) is also supported. ### Gradle Version Support Architectury Loom supports Gradle 7 and up. ",
    "url": "https://docs.architectury.dev/docs/forge_loom/",
    "relUrl": "/docs/forge_loom/"
  },"12": {
    "doc": "KeyMappings",
    "title": "KeyMappings",
    "content": "# KeyMappings {: .no_toc } --- With custom KeyMappings, clients can input from mouse and keyboards to do certain actions. **Note:** The following code should only be executed from client. ## Registering KeyMappings We can register `KeyMapping`s with `KeyMappingRegistry`. First, let's create a `KeyMapping`: ```java // A key mapping with keyboard as the default public static final KeyMapping CUSTOM_KEYMAPPING = new KeyMapping( \"key.examplemod.custom_key\", // The translation key of the name shown in the Controls screen InputConstants.Type.KEYSYM, // This key mapping is for Keyboards by default InputConstants.KEY_P, // The default keycode \"category.examplemod.example\" // The category translation key used to categorize in the Controls screen ); // A key mapping with mouse as the default public static final KeyMapping CUSTOM_KEYMAPPING = new KeyMapping( \"key.examplemod.custom_key\", // The translation key of the name shown in the Controls screen InputConstants.Type.MOUSE, // This key mapping is for Mouse by default InputConstants.MOUSE_BUTTON_LEFT, // The default button \"category.examplemod.example\" // The category translation key used to categorize in the Controls screen ); // A key mapping with no default public static final KeyMapping CUSTOM_KEYMAPPING = new KeyMapping( \"key.examplemod.custom_key\", // The translation key of the name shown in the Controls screen InputConstants.Type.KEYSYM, // This key mapping is for Keyboards by default -1, // The default keycode \"category.examplemod.example\" // The category translation key used to categorize in the Controls screen ); ``` We can register the key mapping in a method now. ```java KeyMappingRegistry.register(CUSTOM_KEYMAPPING); ``` ### Listening to when the key is pressed We will register a client tick event, and consume the key there. ```java ClientTickEvent.CLIENT_POST.register(minecraft -> { while (CUSTOM_KEYMAPPING.consumeClick()) { // Do action here } }); ``` ",
    "url": "https://docs.architectury.dev/docs/architectury_api/keymappings.html",
    "relUrl": "/docs/architectury_api/keymappings.html"
  },"13": {
    "doc": "Networking",
    "title": "Networking",
    "content": "# Networking {: .no_toc } --- There are currently a few ways to setup networking with Architectury API: - [Receiver Callback (Fabric-Like)](#receiver-callback) - [Message Channel (Forge-Like)](#message-channel) ## Differences between Server and Logical Server When you join a world in singleplayer, Minecraft fires a local integrated server. This is to separate the client and the server (logical server) logics, and to allow Opening to LAN. # Receiver Callback Each type of message is differentiated by a `ResourceLocation`, start by statically declaring one, so we can use it later. ```java public static final ResourceLocation EXAMPLE_PACKET_ID = new ResourceLocation(\"examplemod\", \"example_packet\"); ``` ## Registering the Handler Now, depending on the direction of the transmission, we will register the packet receiving handler in a different location. #### Client -> Logical Server When we send a packet from the client to the server, we will register the handler on the common side. #### Logical Server -> Client When we send a packet from the server to the client, we will register the handler on the client side. ```java // We are using S2C here for an example, use C2S instead if this is from the client to the server NetworkManager.registerReceiver(NetworkManager.Side.S2C, EXAMPLE_PACKET_ID, (buf, context) -> { Player player = context.getPlayer(); // Logic }); ``` ## Sending the Packet #### Client -> Logical Server ```java FriendlyPacketBuf buf = new FriendlyPacketBuf(Unpooled.buffer()); NetworkManager.sendToServer(EXAMPLE_PACKET_ID, buf); ``` #### Logical Server -> Client ```java FriendlyPacketBuf buf = new FriendlyPacketBuf(Unpooled.buffer()); NetworkManager.sendToPlayer(player, EXAMPLE_PACKET_ID, buf); ``` ## Handling the Packet The packet buffer supplied is a stream of bytes sent over the network, you must read it in order of how you sent it. Let say, we want to send a block position and an item stack to the server. In between creating the packet buf and sending it, we can write our data to it. ```java FriendlyPacketBuf buf = new FriendlyPacketBuf(Unpooled.buffer()); buf.writeBlockPos(pos); buf.writeItem(stack); NetworkManager.sendToServer(EXAMPLE_PACKET_ID, buf); ``` And then on the server, we can read it. ```java NetworkManager.registerReceiver(NetworkManager.Side.C2S, EXAMPLE_PACKET_ID, (buf, context) -> { BlockPos pos = buf.readBlockPos(); ItemStack stack = buf.readItem(); }); ``` # Message Channel First, we need to register a message channel for our packets to go through. ```java public static final NetworkChannel CHANNEL = NetworkChannel.create(new ResourceLocation(\"examplemod\", \"networking_channel\")); ``` Then, we will create a message class like this: ```java public class ExampleMessage { public ExampleMessage(FriendlyPacketBuf buf) { // Decode data into a message } public ExampleMessage() { // Message creation } public void encode(FriendlyPacketBuf buf) { // Encode data into the buf } public void apply(Supplier contextSupplier) { // On receive } } ``` After this, we will register the message into the channel. ```java CHANNEL.register(ExampleMessage.class, ExampleMessage::encode, ExampleMessage::new, ExampleMessage::apply); ``` ## Attaching more data with the message For any data we want to add to the message, we will want to add fields, then add logic to encode, and decode it over the network. Let say, we want to send a block position and an item stack to the server. ```java public class ExampleMessage { public final BlockPos pos; public final ItemStack stack; public ExampleMessage(FriendlyPacketBuf buf) { this(buf.readBlockPos(), buf.readItem()); } public ExampleMessage(BlockPos pos, ItemStack stack) { this.pos = pos; this.stack = stack; } public void encode(FriendlyPacketBuf buf) { buf.writeBlockPos(pos); buf.writeItem(stack); } public void apply(Supplier contextSupplier) { // Do logic here } } ``` ",
    "url": "https://docs.architectury.dev/docs/architectury_api/networking.html",
    "relUrl": "/docs/architectury_api/networking.html"
  },"14": {
    "doc": "Open Source Licenses",
    "title": "Open Source Licenses",
    "content": "# Open Source Licenses {: .no_toc } --- Parts of this documentation may have been taken from other Open Sourced works. ## [Fabric Wiki](https://fabricmc.net/wiki/) Licensed under [CC Attribution-Noncommercial-Share Alike 4.0 International](http://creativecommons.org/licenses/by-nc-sa/4.0/). ",
    "url": "https://docs.architectury.dev/docs/open_source_licenses.html",
    "relUrl": "/docs/open_source_licenses.html"
  },"15": {
    "doc": "OptiFine Support",
    "title": "OptiFine Support",
    "content": "# OptiFine Support {: .no_toc } --- OptiFine support is not guaranteed with Architectury API. You may attempt using the latest version of OptiFabric / OptiFine with the latest version of Architectury API. # What if I am not able to get OptiFine working? There are a lot of excellent OptiFine alternatives out there in the wild these days, you can mostly follow this guide: [https://lambdaurora.dev/optifine_alternatives/](https://lambdaurora.dev/optifine_alternatives/) ",
    "url": "https://docs.architectury.dev/docs/architectury_api/optifine.html",
    "relUrl": "/docs/architectury_api/optifine.html"
  },"16": {
    "doc": "Platform Specific APIs",
    "title": "Platform Specific APIs",
    "content": "# Platform Specific APIs {: .no_toc } --- ## Don't like annotation magic? Use plain java. Modders are not forced to use Architectury Injectables to access platform-specific APIs. You may just use something simpler, like an interface. ## Architectury Injectables Architectury Plugin adds [Architectury Injectables](https://github.com/architectury/architectury-injectables/) to your common module. ### Disabling Architectury Injectables Inject `injectInjectables = false` in front of `common()` in the common module architectury extension block. ### ArchitecturyTarget Architectury Injectables provide `ArchitecturyTarget.getCurrentTarget()`, which returns the identifier of the current target, it may be (but not limited to): - fabric - forge ### Expect Platform View more at [ExpectPlatform Annotation](/docs/architectury_plugin/expect_platform). ",
    "url": "https://docs.architectury.dev/docs/architectury_plugin/platform_specific.html",
    "relUrl": "/docs/architectury_plugin/platform_specific.html"
  },"17": {
    "doc": "Quick Look",
    "title": "Quick Look",
    "content": "# Quick Look {: .no_toc } --- ## Essential Abstractions | Class Name | Description | Platform | Provides access to the platform's name, environment, etc. | Registries | Provides a platform-agnostic wrapper of minecraft registries, should be used to register content. ([Read More](/docs/architectury_api/registry)) | KeyBindings | Provides method(s) to register the key bindings. | CreativeTabs | Provides method(s) to construct creative tabs. | MenuRegistry | Provides method(s) to construct container menus, and open them. | RenderTypes | Provides method(s) to register render types for blocks and fluids. | ReloadListeners | Provides method(s) to register reloading listeners. | CriteriaTriggersRegistry | Provides method(s) to register criteria triggers. | ColorHandlers | Provides method(s) to register color handlers. | BlockEntityRenderers | Provides method(s) to register block entity renderers. | BiomeModifications | Provides method(s) to modify biome properties. | PackRepositoryHooks | Provides method(s) to add pack repositories. --- ## Networking Abstractions | Class Name | Description | NetworkManager | Provides a Fabric-like networking registry interface. | NetworkChannel | Provides a Forge SimpleChannel-like networking registry interface. --- ## Hooks | Class Name | Description | BiomeHooks | Provides method(s) to access biome properties. | BlockEntityHooks | Provides method(s) to sync data to the client. | DyeColorHooks | Provides method(s) to get the color from a DyeColor. | EntityHooks | Provides method(s) to get the encode ID from an Entity. | ExplosionHooks | Provides method(s) to get unaccessible values from an Explosion. | ItemEntityHooks | Provides method(s) to get unaccessible values from an ItemEntity. | PlayerHooks | Provides method(s) to access unaccessible things from a Player. | ScreenHooks | Provides method(s) to access unaccessible things from a Screen. --- ## Extensions | Class Name | Description | BlockEntityExtensions | Additional extensions to sync data from the server to the client. | BlockProperties | Additional block properties. --- ## Events | Class Name | Description | TooltipEvent | Events related to tooltips. (Client) | TickEvent | Events related to game ticking. | TextureStitchEvent | Events related to texture atlas stitching. (Client) | RecipeUpdateEvent | Event triggered when the client receives recipe updates. (Client) | PlayerEvent | Events related to players. | LifecycleEvent | Events related to lifecycle callbacks. | InteractionEvent | Events related to player interactions. | GuiEvent | Events related to screens. (Client) | ExplosionEvent | Events related to explosions. | EntityEvent | Events related to entities. | CommandRegistrationEvent | Event triggered when commands should be registered. | CommandPerformEvent | Event triggered when commands are executed. | ChatEvent | Events related to chat. | ClientChatEvent | Events related to chat. (Client) | ClientLifecycleEvent | Events related to lifecycle callbacks. (Client) | ClientPlayerEvent | Events related to players. (Client) | ClientScreenInputEvent | Events related to inputs intercepted by the screen. (Client) | ClientTickEvent | Events related to game ticking. (Client) ",
    "url": "https://docs.architectury.dev/docs/architectury_api/quick_look.html",
    "relUrl": "/docs/architectury_api/quick_look.html"
  },"18": {
    "doc": "Regenerating Run Configurations",
    "title": "Regenerating Run Configurations",
    "content": "# Regenerating Run Configurations {: .no_toc } --- ### IntelliJ IDEA Delete the run configurations and refresh Gradle. (You can do this by the run configs prompt) If the run configurations do not show up after refreshing Gradle, try closing the IDEA project and reopening it. ### Visual Studio Code Delete `.vscode` folder and refresh Gradle. ",
    "url": "https://docs.architectury.dev/docs/forge_loom/regenerating_run_configs.html",
    "relUrl": "/docs/forge_loom/regenerating_run_configs.html"
  },"19": {
    "doc": "Registering Content",
    "title": "Registering Content",
    "content": "# Registering Content {: .no_toc } --- ## Why is registering content so complicated? Forge **disallows** you to use vanilla `Registry` class for registering content and requires you to register content in the `RegistryEvent.Register` event, this is different than how you register content in fabric or vanilla. ## Submitting your mod event bus in Forge to Architectury API We will need to pass your mod event bus to Architectury API to allow Architectury API to listen to the registry events on Forge. Each mod's `ModContainer` handles `EventBus` slightly differently, and the mod event bus is inaccessible from other mods. Now, we will expose our mod event bus to Architectury. In your forge mod constructor, do the following: **NOTE: The following tutorial only applies to mods using the `javafml` language provider** ```java EventBuses.registerModEventBus(MOD_ID, FMLJavaModLoadingContext.get().getModEventBus()); ``` ## Registering our content through Architectury's Registries ### Via Registrar **NOTE: The following tutorial is shown in mojmap** We will create a lazy registries object, this is to prevent crashes due to static load orders. ```java public static final Supplier REGISTRIES = Suppliers.memoize(() -> Registries.get(MOD_ID)); ``` During your mods' initialization, you may use this `REGISTRIES` field to get the wrapped registries. With that, we can register our items. ```java Registrar items = REGISTRIES.get().get(Registry.ITEM_KEY); RegistrySupplier exampleItem = items.register(new ResourceLocation(MOD_ID, \"example_item\"), () -> new Item(new Item.Properties())); ``` Notice that the value returned is a `RegistrySupplier`, this is because our content may not have been registered at this point, we might still be waiting for the registry event. ### Via DeferredRegister We will create a deferred register, we will then use this to register our entries. ```java public static final DeferredRegister ITEMS = DeferredRegister.create(MOD_ID, Registry.ITEM_REGISTRY); ``` After statically defining our deferred register, we can add entries to it, please note that the entries are not registered at this point, so we must refrain from accessing them until we actually register them. ```java public static final RegistrySupplier EXAMPLE_ITEM = ITEMS.register(\"example_item\", () -> new Item(new Item.Properties())); ``` We can now submit our registry entries to the registry themselves, we will do this in our initialization block, please make sure that this is called only after we pass our mod event bus to architectury: ```java ITEMS.register(); ``` ",
    "url": "https://docs.architectury.dev/docs/architectury_api/registry.html",
    "relUrl": "/docs/architectury_api/registry.html"
  },"20": {
    "doc": "Using Common Mixins",
    "title": "Using Common Mixins",
    "content": "# Using Common Mixins {: .no_toc } --- **NOTE:** Make sure that the common mixin json name is unique! ### Declaring Common Mixins on Fabric Declare the mixin json path in `fabric/src/main/resources/fabric.mod.json`. ### Declaring Common Mixins on Forge Declaring the following in your `forge/build.gradle`. ```groovy loom { forge { mixinConfig \"mixin.examplemod-common.json\" } } ``` ",
    "url": "https://docs.architectury.dev/docs/architectury_plugin/using_common_mixins.html",
    "relUrl": "/docs/architectury_plugin/using_common_mixins.html"
  },"21": {
    "doc": "Using MCP",
    "title": "Using MCP",
    "content": "# Using MCP {: .no_toc } --- **Note:** MCP is no longer used since Minecraft 1.17, and has been replaced with Official Mojang Mappings. Experimental MCP support is available in Architectury Loom. MCP docs and parameter mappings are fully supported in Forge Loom. However, MCP will **not** work in snapshots, as the MCP support depends on matching the MCPConfig with your intermediary. Declare the MCP mappings dependency as follows: (`20201028-1.16.3` is just an example version!) ```groovy dependencies { mappings \"de.oceanlabs.mcp:mcp_snapshot:20201028-1.16.3\" } ``` ## Using Architectury Loom to remap a MCP mapped project to yarn / mojmap After setting up a loom environment with MCP mappings, you may migrate the code to another mappings. Read the [wiki page](https://fabricmc.net/wiki/tutorial:migratemappings) for more help. #### Migrating to MojMap: `gradlew migrateMappings --mappings \"net.mojang.minecraft:mappings:VERSION\"` #### Migrating to Yarn: (`1.16.5+build.3` is just an example yarn build!) `gradlew migrateMappings --mappings \"1.16.5+build.3\"` ",
    "url": "https://docs.architectury.dev/docs/forge_loom/using_mcp.html",
    "relUrl": "/docs/forge_loom/using_mcp.html"
  },"22": {
    "doc": "Using Mixins",
    "title": "Using Mixins",
    "content": "# Using Mixins {: .no_toc } --- As per traditional Loom fashion, Architectury Loom provides excellent Mixin support out of the box. Architectury Loom also defaults into using the FabricMC's fork of Mixin for better refmap handling in development environments. ### Dependencies with Mixin Architectury Loom works with dependencies with mixin, Architectury Loom injects a remapper into your development environment to properly remap srg reference maps to named. This is all handled for you in Architectury Loom, so you don't need to worry. ### Do I need MixinGradle? No. For a matter of fact, MixinGradle is only responsible for adding the compiler arguments for the Mixin Annotation Processor to create the refmaps. Architectury Loom uses its own [Mixin Compiler Extensions](https://github.com/FabricMC/fabric-mixin-compile-extensions) to create the refmaps, and support for it is directly added in Loom. ### Declaring Mixins The Fabric Mod Loader uses the `fabric.mod.json` to load mixin configs, on Forge, the `MixinConfigs` argument is used instead, Loom will handle adding the arguments for you within both the development environment, and the compiled jar. You must tell Loom what mixins you have, by declaring the following in your `build.gradle`. ```groovy loom { forge { mixinConfig \"mixin.examplemod.json\" } } ``` ",
    "url": "https://docs.architectury.dev/docs/forge_loom/using_mixins.html",
    "relUrl": "/docs/forge_loom/using_mixins.html"
  }
}
